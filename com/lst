     1                                          cpu   8086
     2                                          org   100h 
     3                                  
     4                                  ; Compressed loader.
     5                                  ; Copy self to upper memory (current + 64K)
     6                                  ; Jump to new copy, with 
     7                                  
     8                                  start: 
     9 00000000 8CD8                            mov   ax,ds
    10 00000002 050010                          add   ax,1000h
    11 00000005 8EC0                            mov   es,ax
    12                                  
    13 00000007 BE0001                          mov   si,0x100
    14 0000000A 89F7                            mov   di,si
    15 0000000C F3A4                            rep   movsb
    16                                  
    17 0000000E 06                              push  es
    18 0000000F B8[1400]                        mov   ax,continue
    19 00000012 50                              push  ax
    20 00000013 CB                              retf
    21                                  continue:
    22                                          ; DS is the home segment
    23                                          ; ES is the current segment
    24 00000014 1E                              push  ds
    25 00000015 06                              push  es
    26 00000016 1F                              pop   ds
    27 00000017 07                              pop   es
    28                                  
    29                                          ; ES is the home segment
    30                                          ; DS is the current segment
    31                                          ; push the return address
    32                                          ; uncompress from DS:SI to ES:DI
    33                                  
    34 00000018 BF0001                          mov   di,100h
    35 0000001B BE[7700]                        mov   si,cdata
    36 0000001E 06                              push  es  ; for below {
    37 0000001F 57                              push  di
    38                                  
    39 00000020 E80700                          call  lz4_decompress
    40 00000023 CD03                            int 3
    41 00000025 89C1                            mov   cx,ax ; length of program in CX
    42 00000027 06                              push  es
    43 00000028 1F                              pop   ds
    44                                  
    45 00000029 CB                              retf      ; }
    46                                  
    47                                  %include "LZ4_8088.ASM"
    48                              <1> ; Surprise!  I don't know what assembler you are using (masm, tasm,
    49                              <1> ; nasm, jasm, a86, etc.) so you get to wrap either of these routines for your
    50                              <1> ; specific situation.  Be sure to read the TRASHES comment below.
    51                              <1> ;
    52                              <1> ; The speed-optimized routine is lz4_decompress and the size-optimized
    53                              <1> ; routine is lz4_decompress_small.
    54                              <1> 
    55                              <1> ; function lz4_decompress(inb,outb:pointer):word
    56                              <1> ; 
    57                              <1> ; Decompresses an LZ4 stream file with a compressed chunk 64K or less in size.
    58                              <1> ; Input:
    59                              <1> ;   DS:SI Location of source data.  DWORD magic header and DWORD chunk size
    60                              <1> ;         must be intact; it is best to load the entire LZ4 file into this
    61                              <1> ;         location before calling this code.
    62                              <1> ; 
    63                              <1> ; Output:
    64                              <1> ;   ES:DI Decompressed data.  If using an entire 64K segment, decompression
    65                              <1> ;         is "safe" because overruns will wrap around the segment.
    66                              <1> ;   AX    Size of decompressed data.
    67                              <1> ; 
    68                              <1> ; Trashes AX, BX, CX, DX, SI, DI
    69                              <1> ;         ...so preserve what you need before calling this code.
    70                              <1> 
    71                              <1> lz4_decompress:
    72 0000002A CD03                <1>         int 3
    73 0000002C 57                  <1>         push    di              ;save original starting offset (in case != 0)
    74 0000002D FC                  <1>         cld                     ;make strings copy forward
    75                              <1>         ; lodsw
    76                              <1>         ; lodsw                   ;skip magic number, smaller than "add si,4"
    77 0000002E AD                  <1>         lodsw                   ;load chunk size low 16-bit word
    78 0000002F 93                  <1>         xchg    bx,ax           ;BX = size of compressed chunk
    79 00000030 01F3                <1>         add     bx,si           ;BX = threshold to stop decompression
    80 00000032 AD                  <1>         lodsw                   ;load chunk size high 16-bit word
    81 00000033 91                  <1>         xchg    cx,ax           ;set CX=0 so that AX=0 later
    82 00000034 41                  <1>         inc     cx              ;is high word non-zero?
    83 00000035 E239                <1>         loop    @done           ;If so, chunk too big or malformed, abort
    84                              <1> 
    85                              <1> @parsetoken:                    ;CX=0 here because of REP at end of loop
    86 00000037 91                  <1>         xchg    cx,ax           ;zero ah here to benefit other reg loads
    87 00000038 AC                  <1>         lodsb                   ;grab token to AL
    88 00000039 89C2                <1>         mov     dx,ax           ;preserve packed token in DX
    89                              <1> @copyliterals:
    90 0000003B B104                <1>         mov     cl,4
    91 0000003D D2E8                <1>         shr     al,cl           ;unpack upper 4 bits
    92 0000003F E82000              <1>         call    @buildfullcount ;build full literal count if necessary
    93                              <1> @doliteralcopy:                 ;src and dst might overlap so do this by bytes
    94 00000042 F3A4                <1>         rep     movsb           ;if cx=0 nothing happens
    95                              <1> 
    96                              <1> ;At this point, we might be done; all LZ4 data ends with five literals and the
    97                              <1> ;offset token is ignored.  If we're at the end of our compressed chunk, stop.
    98                              <1> 
    99 00000044 39DE                <1>         cmp     si,bx           ;are we at the end of our compressed chunk?
   100 00000046 7328                <1>         jae     @done           ;if so, jump to exit; otherwise, process match
   101                              <1> 
   102                              <1> @copymatches:
   103 00000048 AD                  <1>         lodsw                   ;AX = match offset
   104 00000049 92                  <1>         xchg    dx,ax           ;AX = packed token, DX = match offset
   105 0000004A 240F                <1>         and     al,0Fh          ;unpack match length token
   106 0000004C E81300              <1>         call    @buildfullcount ;build full match count if necessary
   107                              <1> @domatchcopy:
   108 0000004F 1E                  <1>         push    ds
   109 00000050 96                  <1>         xchg    si,ax           ;ds:si saved
   110 00000051 89FE                <1>         mov     si,di
   111 00000053 29D6                <1>         sub     si,dx
   112 00000055 06                  <1>         push    es
   113 00000056 1F                  <1>         pop     ds              ;ds:si points at match; es:di points at dest
   114 00000057 81C10400            <1>         add     cx,4            ;minimum match is 4
   115 0000005B F3A4                <1>         rep     movsb           ;copy match run; movsb handles si=di-1 condition
   116 0000005D 96                  <1>         xchg    si,ax
   117 0000005E 1F                  <1>         pop     ds              ;ds:si restored
   118 0000005F E9D5FF              <1>         jmp     @parsetoken
   119                              <1> 
   120                              <1> @buildfullcount:
   121 00000062 89C1                <1>         mov     cx,ax           ;CX = unpacked literal length token
   122 00000064 3C0F                <1>         cmp     al,0Fh          ;is it 15?
   123 00000066 7507                <1>         jne     @builddone      ;if not, we have nothing to build
   124                              <1> @buildloop:
   125 00000068 AC                  <1>         lodsb                   ;load a byte
   126 00000069 01C1                <1>         add     cx,ax           ;add it to the full count
   127 0000006B 3CFF                <1>         cmp     al,0xFF         ;was it FFh?
   128 0000006D 74F9                <1>         je      @buildloop      ;if so, keep going
   129                              <1> @builddone:
   130 0000006F C3                  <1>         ret
   131                              <1> 
   132                              <1> @done:
   133 00000070 CD03                <1>       int 3
   134 00000072 58                  <1>         pop     ax              ;retrieve previous starting offset
   135 00000073 29C7                <1>         sub     di,ax           ;subtract prev offset from where we are now
   136 00000075 97                  <1>         xchg    ax,di           ;AX = decompressed size
   137 00000076 C3                  <1>         ret
   138                                  
   139                                  cdata:
   140                                          ; %include "hdr.i"
