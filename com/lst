     1                                          cpu   8086
     2                                          org   100h 
     3                                  
     4                                  ; Compressed loader.
     5                                  ; Copy self to upper memory (current + 64K)
     6                                  ; Jump to new copy, with 
     7                                  
     8                                  start: 
     9 00000000 8B0E[7A00]                      mov   cx,[cdata+4]
    10 00000004 8CD8                            mov   ax,ds
    11 00000006 050010                          add   ax,1000h
    12 00000009 8EC0                            mov   es,ax
    13                                  
    14 0000000B BE0001                          mov   si,0x100
    15 0000000E 89F7                            mov   di,si
    16 00000010 F3A4                            rep   movsb
    17                                  
    18 00000012 06                              push  es
    19 00000013 B8[1800]                        mov   ax,continue
    20 00000016 50                              push  ax
    21 00000017 CB                              retf
    22                                  continue:
    23                                          ; DS is the home segment
    24                                          ; ES is the current segment
    25 00000018 1E                              push  ds
    26 00000019 06                              push  es
    27 0000001A 1F                              pop   ds
    28 0000001B 07                              pop   es
    29                                  
    30                                          ; ES is the home segment
    31                                          ; DS is the current segment
    32                                          ; push the return address
    33                                          ; uncompress from DS:SI to ES:DI
    34                                  
    35 0000001C BF0001                          mov   di,100h
    36 0000001F BE[7600]                        mov   si,cdata
    37 00000022 06                              push  es  ; for below {
    38 00000023 57                              push  di
    39                                  
    40 00000024 E80500                          call  lz4_decompress
    41 00000027 89C1                            mov   cx,ax ; length of program in CX
    42 00000029 06                              push  es
    43 0000002A 1F                              pop   ds
    44                                  
    45 0000002B CB                              retf      ; }
    46                                  
    47                                  %include "LZ4_8088.ASM"
    48                              <1> ; Surprise!  I don't know what assembler you are using (masm, tasm,
    49                              <1> ; nasm, jasm, a86, etc.) so you get to wrap either of these routines for your
    50                              <1> ; specific situation.  Be sure to read the TRASHES comment below.
    51                              <1> ;
    52                              <1> ; The speed-optimized routine is lz4_decompress and the size-optimized
    53                              <1> ; routine is lz4_decompress_small.
    54                              <1> 
    55                              <1> ; function lz4_decompress(inb,outb:pointer):word
    56                              <1> ; 
    57                              <1> ; Decompresses an LZ4 stream file with a compressed chunk 64K or less in size.
    58                              <1> ; Input:
    59                              <1> ;   DS:SI Location of source data.  DWORD magic header and DWORD chunk size
    60                              <1> ;         must be intact; it is best to load the entire LZ4 file into this
    61                              <1> ;         location before calling this code.
    62                              <1> ; 
    63                              <1> ; Output:
    64                              <1> ;   ES:DI Decompressed data.  If using an entire 64K segment, decompression
    65                              <1> ;         is "safe" because overruns will wrap around the segment.
    66                              <1> ;   AX    Size of decompressed data.
    67                              <1> ; 
    68                              <1> ; Trashes AX, BX, CX, DX, SI, DI
    69                              <1> ;         ...so preserve what you need before calling this code.
    70                              <1> 
    71                              <1> lz4_decompress:
    72 0000002C 57                  <1>         push    di              ;save original starting offset (in case != 0)
    73 0000002D FC                  <1>         cld                     ;make strings copy forward
    74 0000002E AD                  <1>         lodsw
    75 0000002F AD                  <1>         lodsw                   ;skip magic number, smaller than "add si,4"
    76 00000030 AD                  <1>         lodsw                   ;load chunk size low 16-bit word
    77 00000031 93                  <1>         xchg    bx,ax           ;BX = size of compressed chunk
    78 00000032 01F3                <1>         add     bx,si           ;BX = threshold to stop decompression
    79 00000034 AD                  <1>         lodsw                   ;load chunk size high 16-bit word
    80 00000035 91                  <1>         xchg    cx,ax           ;set CX=0 so that AX=0 later
    81 00000036 41                  <1>         inc     cx              ;is high word non-zero?
    82 00000037 E238                <1>         loop    @done           ;If so, chunk too big or malformed, abort
    83                              <1> 
    84                              <1> @parsetoken:                    ;CX=0 here because of REP at end of loop
    85 00000039 91                  <1>         xchg    cx,ax           ;zero ah here to benefit other reg loads
    86 0000003A AC                  <1>         lodsb                   ;grab token to AL
    87 0000003B 89C2                <1>         mov     dx,ax           ;preserve packed token in DX
    88                              <1> @copyliterals:
    89 0000003D B104                <1>         mov     cl,4
    90 0000003F D2E8                <1>         shr     al,cl           ;unpack upper 4 bits
    91 00000041 E81F00              <1>         call    @buildfullcount ;build full literal count if necessary
    92                              <1> @doliteralcopy:                 ;src and dst might overlap so do this by bytes
    93 00000044 F3A4                <1>         rep     movsb           ;if cx=0 nothing happens
    94                              <1> 
    95                              <1> ;At this point, we might be done; all LZ4 data ends with five literals and the
    96                              <1> ;offset token is ignored.  If we're at the end of our compressed chunk, stop.
    97                              <1> 
    98 00000046 39DE                <1>         cmp     si,bx           ;are we at the end of our compressed chunk?
    99 00000048 7327                <1>         jae     @done           ;if so, jump to exit; otherwise, process match
   100                              <1> 
   101                              <1> @copymatches:
   102 0000004A AD                  <1>         lodsw                   ;AX = match offset
   103 0000004B 92                  <1>         xchg    dx,ax           ;AX = packed token, DX = match offset
   104 0000004C 240F                <1>         and     al,0Fh          ;unpack match length token
   105 0000004E E81200              <1>         call    @buildfullcount ;build full match count if necessary
   106                              <1> @domatchcopy:
   107 00000051 1E                  <1>         push    ds
   108 00000052 96                  <1>         xchg    si,ax           ;ds:si saved
   109 00000053 89FE                <1>         mov     si,di
   110 00000055 29D6                <1>         sub     si,dx
   111 00000057 06                  <1>         push    es
   112 00000058 1F                  <1>         pop     ds              ;ds:si points at match; es:di points at dest
   113 00000059 81C10400            <1>         add     cx,4            ;minimum match is 4
   114 0000005D F3A4                <1>         rep     movsb           ;copy match run; movsb handles si=di-1 condition
   115 0000005F 96                  <1>         xchg    si,ax
   116 00000060 1F                  <1>         pop     ds              ;ds:si restored
   117 00000061 EBD6                <1>         jmp     @parsetoken
   118                              <1> 
   119                              <1> @buildfullcount:
   120 00000063 89C1                <1>         mov     cx,ax           ;CX = unpacked literal length token
   121 00000065 3C0F                <1>         cmp     al,0Fh          ;is it 15?
   122 00000067 7507                <1>         jne     @builddone      ;if not, we have nothing to build
   123                              <1> @buildloop:
   124 00000069 AC                  <1>         lodsb                   ;load a byte
   125 0000006A 01C1                <1>         add     cx,ax           ;add it to the full count
   126 0000006C 3CFF                <1>         cmp     al,0xFF         ;was it FFh?
   127 0000006E 74F9                <1>         je      @buildloop      ;if so, keep going
   128                              <1> @builddone:
   129 00000070 C3                  <1>         ret
   130                              <1> 
   131                              <1> @done:
   132 00000071 58                  <1>         pop     ax              ;retrieve previous starting offset
   133 00000072 29C7                <1>         sub     di,ax           ;subtract prev offset from where we are now
   134 00000074 97                  <1>         xchg    ax,di           ;AX = decompressed size
   135 00000075 C3                  <1>         ret
   136                                  
   137                                  cdata:
